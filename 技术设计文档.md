# 老人短视频虚假信息检测系统 - 技术设计文档

## 1. 系统架构概览

### 1.1 整体架构
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   前端展示层     │    │   AI检测服务     │    │   数据存储层     │
│                 │    │                 │    │                 │
│ • Web模拟器     │────│ • 语音转文字     │────│ • 用户数据库     │
│ • 智能浮窗      │    │ • 文本分析      │    │ • 检测历史      │
│ • 管理界面      │    │ • 风险评估      │    │ • 模型存储      │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

### 1.2 技术栈选择

#### 前端技术栈
- **框架**: React.js + TypeScript
- **UI库**: Ant Design (适配老人使用习惯)
- **样式**: CSS Modules + Styled Components
- **状态管理**: Redux Toolkit
- **音频处理**: Web Audio API + MediaRecorder API

#### 后端技术栈
- **框架**: Python FastAPI
- **AI框架**: PyTorch + Transformers
- **语音处理**: OpenAI Whisper / 百度语音API
- **数据库**: PostgreSQL + Redis (缓存)
- **消息队列**: RabbitMQ
- **部署**: Docker + Kubernetes

#### AI/ML技术栈
- **语言模型**: BERT-based中文模型 (如Chinese-BERT-wwm)
- **文本分类**: 微调的BERT分类器
- **语音识别**: Whisper或百度语音API
- **训练框架**: PyTorch + Transformers + Datasets

## 2. 详细技术设计

### 2.1 前端架构设计

#### 2.1.1 Web模拟器设计
```typescript
// 短视频模拟器组件结构
interface VideoSimulator {
  // 视频播放区域
  videoPlayer: VideoPlayer;
  // 浮窗检测组件
  detectionFloater: DetectionFloater;
  // 音频捕获
  audioCapture: AudioCapture;
  // OCR文字识别
  textCapture: TextCapture;
}

// 浮窗组件设计 (老人友好)
interface DetectionFloater {
  // 风险等级显示
  riskLevel: 'safe' | 'warning' | 'danger';
  // 大图标显示
  iconSize: 'large'; // 64px+
  // 简单文字说明
  message: string;
  // 操作按钮
  actions: ['关闭', '详情', '举报'];
}
```

#### 2.1.2 用户界面适老化设计
- **字体**: 最小16px，推荐18-20px
- **颜色**: 高对比度，绿色(安全)/黄色(警告)/红色(危险)
- **按钮**: 最小44px点击区域
- **语音**: 支持语音播报检测结果

### 2.2 AI检测服务设计

#### 2.2.1 检测流水线架构
```python
class DetectionPipeline:
    """虚假信息检测流水线"""
    
    def __init__(self):
        self.speech_to_text = WhisperSTT()
        self.text_classifier = FakeNewsClassifier()
        self.risk_assessor = RiskAssessor()
    
    async def detect(self, audio_data: bytes, text_data: str) -> DetectionResult:
        # 1. 语音转文字
        speech_text = await self.speech_to_text.transcribe(audio_data)
        
        # 2. 合并文本内容
        full_text = self.merge_text(speech_text, text_data)
        
        # 3. 特征提取和分类
        features = self.extract_features(full_text)
        classification = await self.text_classifier.classify(features)
        
        # 4. 风险评估
        risk_score = self.risk_assessor.assess(classification)
        
        return DetectionResult(
            risk_level=self.get_risk_level(risk_score),
            confidence=classification.confidence,
            reasons=classification.reasons,
            suggestions=self.get_suggestions(classification)
        )
```

#### 2.2.2 AI模型设计

**a) 文本分类模型**
```python
class FakeNewsClassifier:
    """基于BERT的虚假信息分类器"""
    
    def __init__(self):
        # 使用中文BERT预训练模型
        self.model = BertForSequenceClassification.from_pretrained(
            'chinese-bert-wwm-ext',
            num_labels=3  # 安全/可疑/危险
        )
        self.tokenizer = BertTokenizer.from_pretrained('chinese-bert-wwm-ext')
    
    def preprocess(self, text: str) -> Dict:
        """文本预处理"""
        # 清理文本
        cleaned_text = self.clean_text(text)
        
        # 特征工程
        features = {
            'text': cleaned_text,
            'contains_money_keywords': self.check_money_keywords(text),
            'contains_medical_keywords': self.check_medical_keywords(text),
            'urgency_score': self.calculate_urgency(text),
            'contact_info_present': self.detect_contact_info(text)
        }
        
        return features
    
    def extract_domain_features(self, text: str) -> Dict:
        """提取领域特定特征"""
        return {
            # 金融诈骗特征
            'financial_fraud': {
                'investment_promises': self.detect_investment_promises(text),
                'guaranteed_returns': self.detect_guaranteed_returns(text),
                'urgency_tactics': self.detect_urgency_tactics(text),
            },
            # 医疗虚假信息特征
            'medical_misinformation': {
                'miracle_cures': self.detect_miracle_cures(text),
                'medical_authority_claims': self.detect_fake_authority(text),
                'health_scares': self.detect_health_scares(text),
            }
        }
```

**b) 训练数据结构**
```python
# 训练数据格式
TrainingData = {
    "text": "投资理财文本内容",
    "label": 0,  # 0:安全, 1:可疑, 2:危险
    "domain": "financial",  # financial, medical, general
    "features": {
        "keywords": ["投资", "理财", "收益"],
        "risk_indicators": ["保证", "无风险", "高回报"],
        "contact_methods": ["微信", "电话", "QQ"]
    },
    "metadata": {
        "source": "抖音",
        "video_id": "xxx",
        "timestamp": "2025-01-27"
    }
}
```

### 2.3 数据库设计

#### 2.3.1 用户相关表
```sql
-- 用户表
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    elderly_user_id VARCHAR(50) UNIQUE,
    family_contacts JSONB,  -- 家人联系方式
    settings JSONB,         -- 个人设置
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- 检测历史表
CREATE TABLE detection_history (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id),
    content_text TEXT,
    risk_level VARCHAR(20),
    confidence FLOAT,
    detection_time TIMESTAMP DEFAULT NOW(),
    platform VARCHAR(50),   -- 抖音、微信等
    handled BOOLEAN DEFAULT FALSE
);

-- 训练数据表
CREATE TABLE training_data (
    id SERIAL PRIMARY KEY,
    text_content TEXT NOT NULL,
    label INTEGER NOT NULL,  -- 0:安全, 1:可疑, 2:危险
    domain VARCHAR(50),      -- financial, medical
    features JSONB,
    source VARCHAR(100),
    created_at TIMESTAMP DEFAULT NOW()
);
```

### 2.4 性能优化设计

#### 2.4.1 实时处理优化
```python
class RealtimeProcessor:
    """实时检测处理器"""
    
    def __init__(self):
        # 使用连接池
        self.redis_pool = aioredis.ConnectionPool.from_url("redis://localhost")
        # 模型缓存
        self.model_cache = ModelCache()
        # 批处理队列
        self.batch_queue = asyncio.Queue(maxsize=100)
    
    async def process_stream(self, audio_stream):
        """流式音频处理"""
        # 分块处理，减少延迟
        async for audio_chunk in audio_stream:
            # 并行处理
            tasks = [
                self.transcribe_chunk(audio_chunk),
                self.extract_text_features(audio_chunk),
            ]
            results = await asyncio.gather(*tasks)
            
            # 缓存中间结果
            await self.cache_results(results)
```

#### 2.4.2 模型部署优化
```python
# 模型量化和优化
class OptimizedModel:
    def __init__(self):
        # 使用ONNX优化推理速度
        self.onnx_model = ort.InferenceSession("model.onnx")
        # 模型量化
        self.quantized_model = self.load_quantized_model()
    
    def optimize_for_inference(self):
        """推理优化"""
        # 1. 模型量化 (INT8)
        # 2. 动态批处理
        # 3. GPU加速 (如果可用)
        # 4. 缓存常用结果
        pass
```

## 3. MVP实现计划

### 3.1 MVP阶段1：基础框架 (Week 1-2)
```
技术任务:
1. 搭建React前端框架
2. 实现基础的视频模拟器界面
3. 搭建FastAPI后端服务
4. 实现简单的文本检测规则引擎
5. 完成前后端API集成
```

### 3.2 MVP阶段2：检测功能 (Week 3-4)
```
技术任务:
1. 集成Web Audio API进行音频捕获
2. 实现基于关键词的初版检测算法
3. 添加浮窗组件和交互逻辑
4. 实现基础的风险等级显示
5. 添加用户设置功能
```

### 3.3 MVP阶段3：AI模型集成 (Week 5-6)
```
技术任务:
1. 收集和标注训练数据
2. 训练基础的文本分类模型
3. 集成语音转文字服务
4. 优化检测准确率和响应速度
5. 添加基本的性能监控
```

## 4. 部署和运维

### 4.1 部署架构
```yaml
# Docker Compose 配置示例
version: '3.8'
services:
  frontend:
    image: elder-detection-frontend:latest
    ports:
      - "3000:3000"
  
  backend:
    image: elder-detection-backend:latest
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://...
      - REDIS_URL=redis://...
  
  database:
    image: postgres:14
    environment:
      - POSTGRES_DB=elder_detection
  
  redis:
    image: redis:7-alpine
```

### 4.2 监控和日志
```python
# 监控指标
class Metrics:
    detection_latency = Histogram('detection_latency_seconds')
    detection_accuracy = Gauge('detection_accuracy_rate')
    user_interactions = Counter('user_interactions_total')
    error_rate = Counter('errors_total')
```

## 5. 安全和隐私

### 5.1 数据安全
- **音频数据**: 本地处理，不存储原始音频
- **文本数据**: 加密存储，定期清理
- **用户隐私**: 最小化数据收集，用户可控制

### 5.2 系统安全
- **API安全**: JWT认证 + CORS配置
- **数据传输**: HTTPS/WSS加密
- **访问控制**: RBAC权限模型

---

**文档版本**: v1.0  
**创建日期**: 2025-01-27  
**技术负责人**: 开发团队
